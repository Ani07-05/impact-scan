"""
Local Vulnerability Knowledge Base with SQLite Caching
Aggregates CVE data from OSV.dev, GitHub Advisory, and NVD
"""

import asyncio
import json
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import aiosqlite
import httpx
from rich.console import Console

console = Console()

# Cache TTLs
VULN_CACHE_TTL = 7 * 24 * 3600  # 7 days
METADATA_CACHE_TTL = 24 * 3600  # 1 day


@dataclass
class VulnerabilityData:
    """Normalized vulnerability data from knowledge base"""

    vuln_id: str
    package_name: str
    ecosystem: str
    severity: str
    cvss_score: Optional[float]
    summary: str
    details: str
    affected_versions: List[str]
    patched_versions: List[str]
    published_date: str
    modified_date: str
    source: str
    aliases: List[str]


@dataclass
class PackageMetadata:
    """Package version and security metadata"""

    package_name: str
    ecosystem: str
    latest_version: str
    safe_versions: List[str]
    versions_with_vulnerabilities: List[str]
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    last_updated: float


class DependencyKnowledgeBase:
    """
    Local SQLite-based cache for vulnerability data.
    Reduces API calls and enables offline operation.
    """

    def __init__(self, cache_dir: Path):
        self.cache_dir = cache_dir
        self.cache_dir.mkdir(parents=True, exist_ok=True)

        self.db_path = self.cache_dir / "vulnerabilities.db"
        self.db: Optional[aiosqlite.Connection] = None

        # HTTP client for API requests
        self.http_client: Optional[httpx.AsyncClient] = None

    async def _get_client(self) -> httpx.AsyncClient:
        """Lazy initialize HTTP client"""
        if self.http_client is None:
            self.http_client = httpx.AsyncClient(
                timeout=30.0, limits=httpx.Limits(max_keepalive_connections=5)
            )
        return self.http_client

    async def _get_db(self) -> aiosqlite.Connection:
        """Lazy initialize database connection"""
        if self.db is None:
            self.db = await aiosqlite.connect(self.db_path)
            await self._init_schema()
        return self.db

    async def close(self):
        """Close database and HTTP client connections"""
        if self.db:
            await self.db.close()
            self.db = None
        if self.http_client:
            await self.http_client.aclose()
            self.http_client = None

    async def _init_schema(self):
        """Initialize SQLite database schema"""
        db = await self._get_db()

        await db.execute("""
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                vuln_id TEXT PRIMARY KEY,
                package_name TEXT NOT NULL,
                ecosystem TEXT NOT NULL,
                severity TEXT,
                cvss_score REAL,
                published_date TEXT,
                modified_date TEXT,
                summary TEXT,
                details TEXT,
                affected_versions TEXT,
                patched_versions TEXT,
                source TEXT,
                last_updated REAL NOT NULL
            )
        """)

        await db.execute("""
            CREATE INDEX IF NOT EXISTS idx_package 
            ON vulnerabilities(package_name, ecosystem)
        """)

        await db.execute("""
            CREATE INDEX IF NOT EXISTS idx_severity 
            ON vulnerabilities(severity)
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS package_versions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                package_name TEXT NOT NULL,
                ecosystem TEXT NOT NULL,
                version TEXT NOT NULL,
                is_vulnerable INTEGER DEFAULT 0,
                latest_version TEXT,
                latest_safe_version TEXT,
                last_checked REAL NOT NULL,
                UNIQUE(package_name, ecosystem, version)
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS vulnerability_aliases (
                vuln_id TEXT,
                alias TEXT,
                alias_type TEXT,
                FOREIGN KEY(vuln_id) REFERENCES vulnerabilities(vuln_id)
            )
        """)

        await db.commit()

    async def get_vulnerabilities(
        self, package: str, version: str, ecosystem: str, force_refresh: bool = False
    ) -> List[Dict[str, Any]]:
        """
        Get vulnerabilities for package@version.
        Uses cache if available and not expired.
        """
        # Check cache first
        if not force_refresh:
            cached = await self._get_cached_vulns(package, ecosystem)
            if cached:
                console.log(f"[dim]Cache hit for {package}@{version}[/dim]")
                return cached

        # Fetch from OSV.dev
        console.log(
            f"[cyan]Fetching vulnerabilities for {package}@{version} from OSV.dev...[/cyan]"
        )
        vulns = await self._fetch_from_osv(package, version, ecosystem)

        # Cache results
        if vulns:
            await self._cache_vulnerabilities(package, ecosystem, vulns)

        return vulns

    async def _get_cached_vulns(
        self, package: str, ecosystem: str
    ) -> Optional[List[Dict[str, Any]]]:
        """Check cache for package vulnerabilities"""
        db = await self._get_db()

        current_time = time.time()
        cache_expiry = current_time - VULN_CACHE_TTL

        cursor = await db.execute(
            """
            SELECT vuln_id, severity, cvss_score, summary, details,
                   affected_versions, patched_versions, source,
                   published_date, modified_date
            FROM vulnerabilities
            WHERE package_name = ? AND ecosystem = ? AND last_updated > ?
            """,
            (package, ecosystem, cache_expiry),
        )

        rows = await cursor.fetchall()

        if not rows:
            return None

        # Convert to list of dicts
        results = []
        for row in rows:
            results.append(
                {
                    "id": row[0],
                    "severity": row[1],
                    "cvss_score": row[2],
                    "summary": row[3],
                    "details": row[4],
                    "affected_versions": json.loads(row[5]) if row[5] else [],
                    "patched_versions": json.loads(row[6]) if row[6] else [],
                    "source": row[7],
                    "published": row[8],
                    "modified": row[9],
                }
            )

        return results

    async def _cache_vulnerabilities(
        self, package: str, ecosystem: str, vulns: List[Dict[str, Any]]
    ):
        """Cache vulnerability data"""
        db = await self._get_db()
        current_time = time.time()

        for vuln in vulns:
            await db.execute(
                """
                INSERT OR REPLACE INTO vulnerabilities
                (vuln_id, package_name, ecosystem, severity, cvss_score,
                 published_date, modified_date, summary, details,
                 affected_versions, patched_versions, source, last_updated)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    vuln.get("id", "UNKNOWN"),
                    package,
                    ecosystem,
                    vuln.get("severity", "UNKNOWN"),
                    vuln.get("cvss_score"),
                    vuln.get("published", ""),
                    vuln.get("modified", ""),
                    vuln.get("summary", ""),
                    vuln.get("details", ""),
                    json.dumps(vuln.get("affected", [])),
                    json.dumps(vuln.get("fixed", [])),
                    vuln.get("source", "OSV"),
                    current_time,
                ),
            )

        await db.commit()

    async def _fetch_from_osv(
        self, package: str, version: str, ecosystem: str
    ) -> List[Dict[str, Any]]:
        """Fetch vulnerabilities from OSV.dev API"""
        client = await self._get_client()

        # Map our ecosystem names to OSV ecosystem names
        ecosystem_map = {
            "python": "PyPI",
            "javascript": "npm",
            "java": "Maven",
            "go": "Go",
            "rust": "crates.io",
            "ruby": "RubyGems",
        }

        osv_ecosystem = ecosystem_map.get(ecosystem.lower(), ecosystem)

        try:
            response = await client.post(
                "https://api.osv.dev/v1/query",
                json={
                    "package": {"name": package, "ecosystem": osv_ecosystem},
                    "version": version,
                },
            )

            if response.status_code == 200:
                data = response.json()
                vulns = data.get("vulns", [])

                # Normalize vulnerability data
                normalized = []
                for vuln in vulns:
                    normalized.append(
                        {
                            "id": vuln.get("id", "UNKNOWN"),
                            "summary": vuln.get("summary", "No description"),
                            "details": vuln.get("details", ""),
                            "severity": self._extract_severity(vuln),
                            "cvss_score": self._extract_cvss_score(vuln),
                            "affected": self._extract_affected_versions(vuln),
                            "fixed": self._extract_fixed_versions(vuln),
                            "published": vuln.get("published", ""),
                            "modified": vuln.get("modified", ""),
                            "source": "OSV",
                            "aliases": vuln.get("aliases", []),
                        }
                    )

                return normalized
            else:
                console.log(f"[yellow]OSV API returned {response.status_code}[/yellow]")
                return []

        except Exception as e:
            console.log(f"[red]Error fetching from OSV: {e}[/red]")
            return []

    def _extract_severity(self, vuln: Dict) -> str:
        """Extract severity from OSV vulnerability"""
        if "severity" in vuln and vuln["severity"]:
            return vuln["severity"][0].get("score", "MODERATE")

        if "database_specific" in vuln:
            return vuln["database_specific"].get("severity", "MODERATE")

        return "MODERATE"

    def _extract_cvss_score(self, vuln: Dict) -> Optional[float]:
        """Extract CVSS score if available"""
        if "severity" in vuln and vuln["severity"]:
            for sev in vuln["severity"]:
                if "score" in sev and isinstance(sev["score"], (int, float)):
                    return float(sev["score"])
        return None

    def _extract_affected_versions(self, vuln: Dict) -> List[str]:
        """Extract affected version ranges"""
        affected = []
        for affect in vuln.get("affected", []):
            for range_data in affect.get("ranges", []):
                for event in range_data.get("events", []):
                    if "introduced" in event:
                        affected.append(f">={event['introduced']}")
                    if "fixed" in event:
                        affected.append(f"<{event['fixed']}")
        return affected or ["*"]

    def _extract_fixed_versions(self, vuln: Dict) -> List[str]:
        """Extract fixed/patched versions"""
        fixed = []
        for affect in vuln.get("affected", []):
            for range_data in affect.get("ranges", []):
                for event in range_data.get("events", []):
                    if "fixed" in event:
                        fixed.append(event["fixed"])
        return fixed

    def get_package_metadata(
        self, package: str, ecosystem: str
    ) -> Optional[PackageMetadata]:
        """
        Get package metadata from cache (synchronous wrapper).
        For real implementation, should query package registries.
        """
        # This is a placeholder - real implementation would:
        # 1. Query PyPI/npm/etc. for latest version
        # 2. Check all versions against vulnerability DB
        # 3. Return comprehensive metadata

        # For now, return None (metadata will be added when available)
        return None

    async def refresh_knowledge_base(self, packages: List[Tuple[str, str, str]]):
        """
        Batch refresh knowledge base for list of (package, version, ecosystem) tuples.
        """
        console.log(
            f"[cyan]Refreshing knowledge base for {len(packages)} packages...[/cyan]"
        )

        # Process in batches to avoid rate limiting
        batch_size = 10
        for i in range(0, len(packages), batch_size):
            batch = packages[i : i + batch_size]
            tasks = [
                self.get_vulnerabilities(pkg, ver, eco, force_refresh=True)
                for pkg, ver, eco in batch
            ]
            await asyncio.gather(*tasks, return_exceptions=True)

            # Rate limiting delay
            if i + batch_size < len(packages):
                await asyncio.sleep(1.0)

        console.log("[green]Knowledge base refresh complete[/green]")

    async def close(self):
        """Close database and HTTP client connections"""
        if self.db:
            await self.db.close()
            self.db = None

        if self.http_client:
            await self.http_client.aclose()
            self.http_client = None
