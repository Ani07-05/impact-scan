rules:
  # Rule 1: Missing OAuth State Parameter (CRITICAL - Hexa Vulnerability)
  - id: python-oauth-missing-state-parameter
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  $URL = (...
                      "https://accounts.google.com/o/oauth2/auth"
                      ...
                  )
              - pattern-not-inside: |
                  $URL = (...
                      ...
                      f"...&state={...}..."
                      ...
                  )
              - pattern-not-inside: |
                  $URL = (...
                      ...
                      "&state=..." + ...
                      ...
                  )
          - patterns:
              - pattern-inside: |
                  $URL = "https://accounts.google.com/o/oauth2/auth" + ...
              - pattern-not: |
                  $URL = "..." + "state=" + ...
              - pattern-not: |
                  $URL = f"...&state={...}..."
    message: |
      Missing OAuth state parameter - CRITICAL CSRF vulnerability.
      The OAuth 2.0 specification (RFC 6749 Section 10.12) REQUIRES a state parameter.

      Attack: Attackers can perform CSRF attacks by tricking victims into completing
      an OAuth flow initiated by the attacker, leading to session fixation and account hijacking.

      Fix: Generate a cryptographically secure state token and validate it in the callback:
        state = secrets.token_urlsafe(32)
        redis.set(f"oauth_state:{state}", "pending", ex=300)
        url = f"{auth_url}&state={state}"
    severity: ERROR
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A01:2021 - Broken Access Control"
      confidence: HIGH
      references:
        - "https://datatracker.ietf.org/doc/html/rfc6749#section-10.12"
        - "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html"

  # Rule 2: Access Token Used Without ID Token Verification (HIGH - Hexa Vulnerability)
  - id: python-oauth-id-token-not-verified
    patterns:
      - pattern-either:
          - pattern: |
              $TOKEN = $RESPONSE.json().get("access_token")
              ...
              $URL = f"https://www.googleapis.com/oauth2/v2/userinfo?access_token={$TOKEN}"
          - pattern: |
              $TOKEN = $RESPONSE["access_token"]
              ...
              $URL = "https://www.googleapis.com/oauth2/v2/userinfo" + ...
    message: |
      OAuth ID token not verified - using access_token for user info without cryptographic verification.

      Attack: Man-in-the-middle attacks can forge responses, token substitution attacks possible,
      no cryptographic proof that the token came from the expected issuer.

      Fix: Verify the ID token signature and claims using google-auth library:
        from google.oauth2 import id_token
        id_info = id_token.verify_oauth2_token(id_token_jwt, request, GOOGLE_CLIENT_ID)
        email = id_info['email']
    severity: ERROR
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-345: Insufficient Verification of Data Authenticity"
      owasp: "A07:2021 - Identification and Authentication Failures"
      confidence: HIGH
      references:
        - "https://developers.google.com/identity/protocols/oauth2/openid-connect#validatinganidtoken"

  # Rule 3: Wildcard CORS with Credentials (HIGH - Hexa Vulnerability)
  - id: python-cors-wildcard-with-credentials
    patterns:
      - pattern: |
          CORSMiddleware(..., allow_origins=["*"], ..., allow_credentials=True, ...)
      - pattern: |
          CORSMiddleware(..., allow_credentials=True, ..., allow_origins=["*"], ...)
    message: |
      CRITICAL: CORS configured with allow_origins=["*"] AND allow_credentials=True.

      Attack: ANY website can make authenticated requests to your API, steal session cookies,
      and perform unauthorized actions on behalf of logged-in users.

      Fix: Specify exact origins:
        allow_origins=["https://yourdomain.com"],
        allow_credentials=True
    severity: ERROR
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-942: Permissive Cross-domain Policy with Untrusted Domains"
      owasp: "A01:2021 - Broken Access Control"
      confidence: HIGH
      references:
        - "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"
        - "https://portswigger.net/web-security/cors"

  # Rule 4: Session Cookie Missing Secure Flag
  - id: python-cookie-missing-secure-flag
    patterns:
      - pattern-either:
          - pattern: |
              $RESPONSE.set_cookie(..., httponly=True, ...)
          - pattern: |
              $RESPONSE.set_cookie($KEY, $VALUE, ...)
      - pattern-not: |
          $RESPONSE.set_cookie(..., secure=True, ...)
      - metavariable-pattern:
          metavariable: $KEY
          patterns:
            - pattern-either:
                - pattern: '"session_id"'
                - pattern: '"session"'
                - pattern: '"auth_token"'
                - pattern: '"token"'
    message: |
      Session/auth cookie set without secure=True flag.

      Risk: Cookie can be transmitted over unencrypted HTTP connections,
      making it vulnerable to man-in-the-middle attacks and session hijacking.

      Fix: Always set secure=True for authentication cookies:
        response.set_cookie(key="session_id", value=token, httponly=True, secure=True, samesite="strict")
    severity: WARNING
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
      owasp: "A05:2021 - Security Misconfiguration"
      confidence: MEDIUM

  # Rule 5: Session Cookie Using SameSite=Lax for Authentication
  - id: python-cookie-samesite-lax-auth
    patterns:
      - pattern: |
          $RESPONSE.set_cookie(..., samesite="lax", ...)
      - metavariable-pattern:
          metavariable: $RESPONSE
          patterns:
            - pattern-either:
                - pattern: |
                    $RESPONSE.set_cookie($KEY, ...)
      - metavariable-pattern:
          metavariable: $KEY
          patterns:
            - pattern-either:
                - pattern: '"session_id"'
                - pattern: '"session"'
                - pattern: '"auth_token"'
    message: |
      Authentication cookie using samesite="lax" instead of "strict".

      Risk: Cookies sent on top-level GET requests from external sites,
      allowing some CSRF attacks to succeed.

      Fix: Use samesite="strict" for authentication cookies:
        response.set_cookie(key="session_id", value=token, samesite="strict", secure=True, httponly=True)
    severity: WARNING
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A01:2021 - Broken Access Control"
      confidence: MEDIUM

  # Rule 6: JavaScript - Missing State Parameter in OAuth URL
  - id: javascript-oauth-missing-state
    patterns:
      - pattern-inside: |
          const $URL = `https://accounts.google.com/o/oauth2/auth...`
      - pattern-not: |
          const $URL = `...&state=${...}...`
    message: |
      Missing OAuth state parameter in JavaScript OAuth flow.

      Fix: Generate and validate state parameter:
        const state = crypto.randomBytes(32).toString('hex');
        await redis.set(`oauth_state:${state}`, 'pending', 'EX', 300);
        const url = `${authUrl}&state=${state}`;
    severity: ERROR
    languages: [javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A01:2021 - Broken Access Control"

  # Rule 7: Express CORS Wildcard with Credentials
  - id: javascript-cors-wildcard-credentials
    patterns:
      - pattern-either:
          - pattern: |
              cors({origin: "*", credentials: true})
          - pattern: |
              cors({credentials: true, origin: "*"})
    message: |
      Express CORS configured with wildcard origin and credentials enabled.

      Attack: Any website can make authenticated requests to your API.

      Fix: Specify allowed origins:
        cors({origin: 'https://yourdomain.com', credentials: true})
    severity: ERROR
    languages: [javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-942: Permissive Cross-domain Policy with Untrusted Domains"
      owasp: "A01:2021 - Broken Access Control"

  # Rule 8: Express Session Without Secure Cookie
  - id: javascript-session-cookie-insecure
    patterns:
      - pattern: |
          session({..., cookie: {httpOnly: true, ...}, ...})
      - pattern-not: |
          session({..., cookie: {..., secure: true, ...}, ...})
    message: |
      Express session cookie missing secure flag.

      Fix: Set secure: true in production:
        session({
          cookie: {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict'
          }
        })
    severity: WARNING
    languages: [javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
      owasp: "A05:2021 - Security Misconfiguration"
