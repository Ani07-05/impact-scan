rules:
  # Rule 1: PyJWT Decode Without Signature Verification
  - id: python-jwt-decode-without-verify
    pattern-either:
      - pattern: |
          jwt.decode($TOKEN, options={"verify_signature": False})
      - pattern: |
          jwt.decode($TOKEN, ..., options={"verify_signature": False}, ...)
      - pattern: |
          jwt.decode($TOKEN, verify=False)
    message: |
      JWT token decoded without signature verification - CRITICAL vulnerability.

      Attack: Attackers can forge tokens with arbitrary claims, completely bypassing authentication.
      Any attacker can create valid-looking tokens and gain unauthorized access.

      Fix: Remove options={"verify_signature": False} and verify with proper secret:
        decoded = jwt.decode(token, secret_key, algorithms=["HS256"])
    severity: ERROR
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-347: Improper Verification of Cryptographic Signature"
      owasp: "A02:2021 - Cryptographic Failures"
      confidence: HIGH
      references:
        - "https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/"

  # Rule 2: PyJWT Decode Missing Algorithm Specification
  - id: python-jwt-missing-algorithm
    patterns:
      - pattern-either:
          - pattern: |
              jwt.decode($TOKEN, $SECRET)
          - pattern: |
              jwt.decode($TOKEN, $SECRET, ...)
      - pattern-not: |
          jwt.decode($TOKEN, $SECRET, algorithms=[...])
      - pattern-not: |
          jwt.decode($TOKEN, $SECRET, ..., algorithms=[...], ...)
    message: |
      JWT decode missing algorithm specification - allows algorithm confusion attacks.

      Attack: Attackers can change the algorithm in the token header (e.g., RS256 to HS256)
      and use the public key as the HMAC secret to forge signatures.

      Fix: Always specify allowed algorithms:
        decoded = jwt.decode(token, secret, algorithms=["HS256"])
        # Or for RSA: algorithms=["RS256"]
    severity: WARNING
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-327: Use of Broken Cryptographic Algorithm"
      owasp: "A02:2021 - Cryptographic Failures"
      confidence: HIGH
      references:
        - "https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/"
        - "https://nvd.nist.gov/vuln/detail/CVE-2022-29217"

  # Rule 3: PyJWT Hardcoded Secret
  - id: python-jwt-hardcoded-secret
    pattern-either:
      - pattern: |
          jwt.encode($PAYLOAD, "...", ...)
      - pattern: |
          jwt.decode($TOKEN, "...", ...)
      - patterns:
          - pattern-either:
              - pattern: |
                  $SECRET = "..."
              - pattern: |
                  JWT_SECRET = "..."
              - pattern: |
                  SECRET_KEY = "..."
          - pattern: |
              jwt.encode(..., $SECRET, ...)
          - pattern-not: |
              $SECRET = os.environ.get(...)
          - pattern-not: |
              $SECRET = config.get(...)
    message: |
      Hardcoded JWT secret detected - CRITICAL security risk.

      Risk: If source code is exposed (git leaks, decompilation, etc.),
      attackers can forge valid tokens and gain unauthorized access.

      Fix: Use environment variables or secure key management:
        SECRET_KEY = os.environ["JWT_SECRET"]
        token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")
    severity: ERROR
    languages: [python]
    metadata:
      category: security
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A07:2021 - Identification and Authentication Failures"
      confidence: HIGH

  # Rule 4: JavaScript - JWT Decode Instead of Verify
  - id: javascript-jwt-decode-without-verify
    patterns:
      - pattern: |
          jwt.decode($TOKEN)
      - pattern-not: |
          jwt.verify($TOKEN, ...)
    message: |
      Using jwt.decode() instead of jwt.verify() - no signature verification.

      Attack: jwt.decode() only decodes the token without verifying the signature,
      allowing attackers to forge tokens.

      Fix: Use jwt.verify() to ensure signature verification:
        const decoded = jwt.verify(token, secretKey, { algorithms: ['HS256'] });
    severity: ERROR
    languages: [javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-347: Improper Verification of Cryptographic Signature"
      owasp: "A02:2021 - Cryptographic Failures"
      confidence: HIGH

  # Rule 5: JavaScript - "none" Algorithm
  - id: javascript-jwt-none-algorithm
    pattern-either:
      - pattern: |
          jwt.sign($PAYLOAD, $SECRET, {algorithm: "none"})
      - pattern: |
          jwt.sign($PAYLOAD, null, {algorithm: "none"})
      - pattern: |
          jwt.sign($PAYLOAD, $SECRET, {..., algorithm: "none", ...})
      - pattern: |
          jwt.verify($TOKEN, $SECRET, {..., algorithms: ["none"], ...})
      - pattern: |
          jwt.verify($TOKEN, $SECRET, {..., algorithms: [..., "none", ...], ...})
    message: |
      JWT signed/verified with "none" algorithm - CRITICAL vulnerability.

      Attack: The "none" algorithm disables signature verification entirely.
      Attackers can create unsigned tokens that will be accepted as valid.

      Fix: Use secure algorithms and never include "none":
        jwt.sign(payload, secretKey, { algorithm: 'HS256' });
        jwt.verify(token, secretKey, { algorithms: ['HS256', 'RS256'] });
    severity: ERROR
    languages: [javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-327: Use of Broken Cryptographic Algorithm"
      owasp: "A02:2021 - Cryptographic Failures"
      confidence: HIGH
      references:
        - "https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/"
        - "https://nvd.nist.gov/vuln/detail/CVE-2015-9235"

  # Rule 6: JavaScript - Hardcoded JWT Secret
  - id: javascript-jwt-hardcoded-secret
    pattern-either:
      - pattern: |
          jwt.sign($PAYLOAD, "...", ...)
      - pattern: |
          jwt.verify($TOKEN, "...", ...)
      - patterns:
          - pattern-either:
              - pattern: |
                  const $SECRET = "..."
              - pattern: |
                  const JWT_SECRET = "..."
              - pattern: |
                  var $SECRET = "..."
          - pattern: |
              jwt.sign(..., $SECRET, ...)
          - pattern-not: |
              const $SECRET = process.env...
          - pattern-not: |
              const $SECRET = config...
    message: |
      Hardcoded JWT secret in JavaScript code.

      Risk: Exposed secrets allow attackers to forge valid tokens.

      Fix: Use environment variables:
        const SECRET_KEY = process.env.JWT_SECRET;
        jwt.sign(payload, SECRET_KEY, { algorithm: 'HS256' });
    severity: ERROR
    languages: [javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A07:2021 - Identification and Authentication Failures"
      confidence: HIGH

  # Rule 7: JWT Token Without Expiration
  - id: jwt-missing-expiration
    patterns:
      - pattern-either:
          - pattern: |
              jwt.encode($PAYLOAD, $SECRET, ...)
          - pattern: |
              jwt.sign($PAYLOAD, $SECRET, ...)
      - pattern-not: |
          jwt.encode({..., "exp": ..., ...}, ...)
      - pattern-not: |
          jwt.sign({..., exp: ..., ...}, ...)
    message: |
      JWT token created without expiration time (exp claim).

      Risk: Tokens never expire, allowing unlimited access if stolen.
      Stolen tokens can be used indefinitely for unauthorized access.

      Fix: Always set an expiration time:
        Python: payload = {"user_id": user_id, "exp": datetime.utcnow() + timedelta(hours=1)}
        JavaScript: jwt.sign(payload, secret, { expiresIn: '1h' });
    severity: WARNING
    languages: [python, javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-613: Insufficient Session Expiration"
      owasp: "A07:2021 - Identification and Authentication Failures"
      confidence: MEDIUM

  # Rule 8: Weak JWT Secret
  - id: jwt-weak-secret
    pattern-either:
      - pattern: |
          $SECRET = "secret"
      - pattern: |
          $SECRET = "password"
      - pattern: |
          $SECRET = "123456"
      - pattern: |
          JWT_SECRET = "secret"
      - pattern: |
          SECRET_KEY = "secret"
    fix: |
      # Generate strong secret:
      # Python: secrets.token_urlsafe(32)
      # Bash: openssl rand -base64 32
    message: |
      Weak JWT secret detected - easily guessable.

      Risk: Weak secrets can be cracked through brute-force attacks,
      allowing attackers to forge valid tokens.

      Fix: Use cryptographically secure secrets (32+ bytes):
        import secrets
        SECRET_KEY = secrets.token_urlsafe(32)
        # Or use environment variable with strong generated secret
    severity: ERROR
    languages: [python, javascript, typescript]
    metadata:
      category: security
      cwe: "CWE-521: Weak Password Requirements"
      owasp: "A07:2021 - Identification and Authentication Failures"
      confidence: HIGH
